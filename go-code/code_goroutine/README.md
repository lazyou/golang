### goroutine
* 一个应用程序是运行在机器上的一个 __进程__

* __进程__ 是一个运行在 _自己内存地址空间里_ 的独立执行体

* 一个进程由一个或多个操作系统 __线程__ 组成，这些线程其实是共享同一个内存地址空间的一起工作的执行体

* __不要使用全局变量或者共享内存，它们会给你的代码在并发运算的时候带来危险__
    * 解决之道在于同步不同的线程，对数据 __加锁__，这样同时就 __只有一个线程可以变更数据__

* __协程__ 工作在相同的地址空间中，所以 __共享内存的方式一定是同步的__ (这个可以使用 `sync` 包来实现)

* 不过我们很不鼓励这样做：Go 使用 `channels` 来同步协程

* 当系统调用（比如等待 I/O）阻塞协程时，其他协程会继续在其他线程上工作

* 任何 Go 程序都必须有的 `main()` 函数也可以看做是一个协程，尽管它并没有通过 go 来启动


### 并发和并行的差异
* Go 的并发原语提供了良好的 __并发__ 设计基础：表达程序结构以便表示独立地执行的动作

* Go的重点 __不在于并行__ 的首要位置：并发程序可能是并行的，也可能不是。

* Go 默认没有并行指令，__只有一个独立的核心或处理器被专门用于 Go 程序__，不论它启动了多少个协程；
    * 所以这些协程是并发运行的，但他们不是并行运行的：同一时间只有一个协程会处在运行状态。

    * __开启并行__: 为了使你的程序可以使用多个核心运行，这时协程就真正的是并行运行了，你必须使用 `GOMAXPROCS` 变量


### 使用 GOMAXPROCS
* 所有的协程都会共享同一个线程 _除非_ 将 `GOMAXPROCS` 设置为一个大于 1 的数

* 如果在某一时间只有一个协程在执行，不要设置 `GOMAXPROCS`！


### Go 协程（goroutines）和协程（coroutines）
* 比如 C#，Lua 或者 Python 都有协程的概念。这个名字表明它和 Go协程有些相似，不过有两点不同：
    * Go 协程意味着并行（或者可以以并行的方式部署），协程一般来说不是这样的
    * Go 协程通过通道来通信；协程通过让出和恢复操作来通信


### channel
* 在其他协程运行时让 `main` 程序无限阻塞的通常做法是在 `main` 函数的最后放置一个 `select {}`

* 也可以使用通道来达到同步的目的，这个很有效的用法在传统计算机中称为 __信号量___（semaphore）。
    * 或者换个方式：通过通道发送信号告知处理已经完成（在协程中）。

* 信号量是实现互斥锁（排外锁）常见的同步机制，限制对资源的访问，解决读写问题
