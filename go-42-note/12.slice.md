## 12.1 切片(slice)
* __切片__（slice） 是对底层数组一个连续片段的引用（该数组我们称之为相关数组，通常是匿名的），所以 __切片是一个引用类型__（和数组不一样）

* 未初始化切片的值为 nil。

* 切片提供了计算容量的函数 cap() ，可以测量切片最大长度。切片的长度永远不会超过它的容量，所以对于切片 s 来说，这个不等式永远成立：0 <= len(s) <= cap(s)。

* 使用内置函数 make() 可以给切片初始化，该函数指定切片类型和指定长度和可选容量的参数。
    * `var slice1 []type = make([]type, len,cap)`

### 优点
* 因为切片是引用，所以它们不需要使用额外的内存并且比使用数组更有效率，所以 __在 Go 代码中切片比数组更常用__。

* 声明切片的格式是： `var identifier []type`（不需要说明长度）。一个切片在未初始化之前默认为 `nil，长度为 0。

* 切片的初始化格式是： `var slice1 []type = arr1[start:end]`


## 12.2 切片重组(reslice)
* 通过改变切片长度得到新切片的过程称之为切片重组 reslicing，做法如下：`slice1 = slice1[0:end]`

* __注意__： 当我们在一个 slice 基础上重新划分一个 slice 时，新的 slice 会继续引用原有 slice 的数组。如果你忘了这个行为的话，在你的应用分配大量临时的 slice 用于创建新的 slice 来引用原有数据的一小部分时，会导致难以预期的内存使用。

* 为了避免这个陷阱，我们需要从临时的 slice 中使用内置函数 `copy()`，拷贝数据（而不是重新划分 slice）到新切片。

* append() 函数将 0 个或多个具有相同类型 S 的元素追加到切片s后面并且返回新的切片；追加的元素必须和原切片的元素同类型。__如果 s 的容量不足以存储新增元素，append 会分配新的切片来保证已有切片元素和新增元素的存储__。
