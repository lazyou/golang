## 24.1 指针
* 一个指针变量可以指向任何一个 __值的内存地址___
    * 它指向那个值的内存地址，在 32 位机器上占用 4 个字节，在 64 位机器上占用 8 个字节，并且与它所指向的值的大小无关。
    
    * 可以在指针类型前面加上 `*` 号（前缀）来 __获取指针所指向的内容__，这里的 `*` 号是一个类型更改器
    
    
* 当一个指针被定义后没有分配到任何变量时，它的值为 `nil`

* 对于任何一个变量 var， 如下表达式都是正确的：`var == *(&var)`

* 你不能得到一个数字或常量的地址，下面的写法是错误的:
    ```go
    const i = 5
    ptr := &i // error: cannot take the address of i
    ptr2 := &10 // error: cannot take the address of 10
    ```

* 相关操作符: 
    * `&` 取地址符号
    * `*` 取值符号

* Go 语言中的指针保证了内存安全，更像是 Java、C# 和 VB.NET 中的引用。
    * 因此 `c = *p++` 在 Go 语言的代码中是不合法的。
      
* 指针的一个高级应用是你可以传递一个变量的引用（如函数的参数），这样不会传递变量的拷贝
    * 指针传递是很廉价的，只占用 4 个或 8 个字节。    

* 指针也可以指向另一个指针，并且可以进行任意深度的嵌套 (但是最好不要这么做)

* __指针的使用方法__：
    * 定义指针变量；
    
    * 为指针变量赋值；
    
    * 访问指针变量中指向地址的值；
    
    * 在指针类型前面加上 * 号来获取指针所指向的内容。
 
 * eg: 24/pointer.go
 
 
## 24.2 new() 和 make() 的区别
* 看起来二者没有什么区别， __都在堆上分配内存__，但是它们的行为不同，适用于不同的类型。
    * `new(T)`: 为每个新的类型 T 分配一片内存，初始化为 0 并且返回类型 `*T` 的内存地址：这种方法 返回一个指向类型为 T，值为 0 的地址的指针，它 __适用于值类型如数组和结构体__；它相当于 `&T{}`。
      
    * `make(T)`: 返回一个类型为 T 的初始值，它 __只适用于 3 种内建的引用类型：切片、map 和 channel__。
      
* TODO: 重要


## 24.3 垃圾回收和 SetFinalizer

